%%%乘法
%%一、首先确定方案门限值
 a = [5,3];
% 输入多项式的参数，生成每个人相应的密钥
%coef1 = ceil(rand(2,a(2))*10)%随机生成矩阵值
 coef1 = [2,-3,4;
          1,5,-6];%或者自定义矩阵
 s = Sharing(a, coef1);
 mul_s = prod(s,2);
 
%%二、每个P根据自己得到的d生成自己的n-1次多项式，并分发给每个参与者
%coef_H = [ceil(rand(a(1),a(2)-1)*100),mul_s]%随机生成多项式系数矩阵
coef_H = [1,-1,mul_s(1);
          1,-10,mul_s(2);
          1,-100,mul_s(3);
          1,-200,mul_s(4);
         1,-300,mul_s(5)];%或者自定义多项式系数矩阵
%计算C矩阵
CMatrix = CalculateCMatrix1(a,coef_H)

%%三、计算λ矩阵，每个人Pi根据自己得到的5个cji(1 <= j <= 5)
lamda = zeros(1,a(1));
M = zeros(a(1),a(1));
m = [1:1:a(1)]';
for i = 1:a(1)
    M(:,i) = m.^(i-1)
end
% M = [1,1,1,1,1; 
%     1,2,2^2,2^3,2^4; 
%     1,3,3^2,3^3,3^4; 
%     1,4,4^2,4^3,4^4; 
%     1,5,5^2,5^3,5^4];
lamda = [1,0,0,0,0] * inv(M);
%每个人根据自己得到的Cji计算C值
C = lamda * CMatrix;

%%四、进行恢复（比如满足1,3,5人）,根据这几个人计算得到的C值进行恢复
P = [1,3,5];
ab=0;
ab = C(P(1)) * ( (0-P(2)) * (0-P(3)) ) / ( (P(1)-P(2)) * (P(1)-P(3)) ) + ...
     C(P(2)) * ( (0-P(1)) * (0-P(3)) ) / ( (P(2)-P(1)) * (P(2)-P(3)) ) + ...
     C(P(3)) * ( (0-P(1)) * (0-P(2)) ) / ( (P(3)-P(1)) * (P(3)-P(2)) )
%恢复多项式
syms x;
y = C(P(1)) * ( (x-P(2)) * (x-P(3)) ) / ( (P(1)-P(2)) * (P(1)-P(3)) ) + ...
     C(P(2)) * ( (x-P(1)) * (x-P(3)) ) / ( (P(2)-P(1)) * (P(2)-P(3)) ) + ...
     C(P(3)) * ( (x-P(1)) * (x-P(2)) ) / ( (P(3)-P(1)) * (P(3)-P(2)) );
y = expand(y)

       